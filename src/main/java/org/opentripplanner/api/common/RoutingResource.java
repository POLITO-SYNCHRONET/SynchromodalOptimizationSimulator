/* This program is free software: you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public License
 as published by the Free Software Foundation, either version 3 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>. */

package org.opentripplanner.api.common;

import java.util.*;

import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeConstants;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.onebusaway.gtfs.model.AgencyAndId;
import org.opentripplanner.api.parameter.QualifiedModeSet;
import org.opentripplanner.common.geometry.SphericalDistanceLibrary;
import org.opentripplanner.common.model.GenericLocation;
import org.opentripplanner.routing.core.OptimizeType;
import org.opentripplanner.routing.core.RoutingRequest;
import org.opentripplanner.routing.core.TraverseModeSet;
import org.opentripplanner.routing.graph.Vertex;
import org.opentripplanner.routing.request.BannedStopSet;
import org.opentripplanner.standalone.OTPServer;
import org.opentripplanner.standalone.Router;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.opentripplanner.util.ResourceBundleSingleton;
/**
 * This class defines all the JAX-RS query parameters for a path search as fields, allowing them to 
 * be inherited by other REST resource classes (the trip planner and the Analyst WMS or tile 
 * resource). They will be properly included in API docs generated by Enunciate. This implies that
 * the concrete REST resource subclasses will be request-scoped rather than singleton-scoped.
 *
 * All defaults should be specified in the RoutingRequest, NOT as annotations on the query parameters.
 * JSON router configuration can then overwrite those built-in defaults, and only the fields of the resulting prototype
 * routing request for which query parameters are found are overwritten here. This establishes a priority chain:
 * RoutingRequest field initializers, then JSON router config, then query parameters.
 *
 * @author abyrd
 */
public abstract class RoutingResource { 

    private static final Logger LOG = LoggerFactory.getLogger(RoutingResource.class);

    /**
     * The routerId selects between several graphs on the same server. The routerId is pulled from
     * the path, not the query parameters. However, the class RoutingResource is not annotated with
     * a path because we don't want it to be instantiated as an endpoint. Instead, the {routerId}
     * path parameter should be included in the path annotations of all its subclasses.
     */
    @PathParam("routerId") 
    public String routerId;
    
    @QueryParam("username") 
    protected String username;
    
    @QueryParam("passBy")
    protected String passBy;
    
    @QueryParam("BannedStops")
    protected String BannedStops;
    
    @QueryParam("ForcedRoutes")
    protected String ForcedRoutes;
    
    //to be removed
    @QueryParam("to2ndPlace")
    protected String to2ndPlace;
    
    @QueryParam("otherCapacityRequest")
    protected String otherCapacityRequest;
    
    @QueryParam("otherEndNameStr")
    protected String otherEndNameStr;
    
    @QueryParam("otherTimeArriveVisible")
    protected String otherTimeArriveVisible;
    
    @QueryParam("otherDate")
    protected String otherDate;
    
    @QueryParam("otherTime")
    protected String otherTime;
    
    @QueryParam("KRI_time_w")
    protected Double KRI_time_w;
    
    @QueryParam("KRI_flexibility_w")
    protected Double KRI_flexibility_w;
    
    @QueryParam("KRI_safety_w")
    protected Double KRI_safety_w;
    
    @QueryParam("KRI_cost_w")
    protected Double KRI_cost_w;
    
    @QueryParam("riskAnalysis")
    protected boolean riskAnalysis;
    
    @QueryParam("capacityRequest")
    protected Integer capacityRequest;
    
    @QueryParam("boarding_truck")
    protected Double boarding_truck;
    
    @QueryParam("boarding_train")
    protected Double boarding_train;
    
    @QueryParam("boarding_ship")
    protected Double boarding_ship;
    
    @QueryParam("alighting_truck")
    protected Double alighting_truck;
    
    @QueryParam("alighting_train")
    protected Double alighting_train;
    
    @QueryParam("alighting_ship")
    protected Double alighting_ship;
    
    @QueryParam("boarding_ship_roro")
    protected Double boarding_ship_roro;
    
    @QueryParam("alighting_ship_roro")
    protected Double alighting_ship_roro;
    
    @QueryParam("truck_speed")
    protected Double truck_speed;
    
    @QueryParam("capacity_train")
    protected Double capacity_train;
    
    @QueryParam("capacity_ship")
    protected Double capacity_ship;

    /** The start location -- either latitude, longitude pair in degrees or a Vertex
     *  label. For example, <code>40.714476,-74.005966</code> or
     *  <code>mtanyctsubway_A27_S</code>.  */
    @QueryParam("fromPlace")
    protected String fromPlace;

    /** The end location (see fromPlace for format). */
    @QueryParam("toPlace")
    protected String toPlace;

    /** An ordered list of intermediate locations to be visited (see the fromPlace for format). Parameter can be specified multiple times. */
    @QueryParam("intermediatePlaces")
    protected List<String> intermediatePlaces;

    /** The date that the trip should depart (or arrive, for requests where arriveBy is true). */
    @QueryParam("date")
    protected String date;
    
    /** The time that the trip should depart (or arrive, for requests where arriveBy is true). */
    @QueryParam("time")
    protected String time;
    
    
    /** Whether the trip should depart or arrive at the specified date and time. */
    @QueryParam("arriveBy")
    protected Boolean arriveBy;
    
    
    @QueryParam("driverRestTime")
    protected Boolean driverRestTime;
    
    /** Whether the trip must be wheelchair accessible. */
    @QueryParam("wheelchair")
    protected Boolean wheelchair;

    /** The maximum distance (in meters) the user is willing to walk. Defaults to unlimited. */
    @QueryParam("maxWalkDistance")
    protected Double maxWalkDistance;

    /**
     * The maximum time (in seconds) of pre-transit travel when using drive-to-transit (park and
     * ride or kiss and ride). Defaults to unlimited.
     */
    @QueryParam("maxPreTransitTime") //PHUONG: set to 30 min in RoutingRequest
    protected Integer maxPreTransitTime;

    /**
     * A multiplier for how bad walking is, compared to being in transit for equal lengths of time.
     * Defaults to 2. Empirically, values between 10 and 20 seem to correspond well to the concept
     * of not wanting to walk too much without asking for totally ridiculous itineraries, but this
     * observation should in no way be taken as scientific or definitive. Your mileage may vary.
     */
    @QueryParam("walkReluctance")
    protected Double walkReluctance;

    /**
     * How much worse is waiting for a transit vehicle than being on a transit vehicle, as a
     * multiplier. The default value treats wait and on-vehicle time as the same.
     *
     * It may be tempting to set this higher than walkReluctance (as studies often find this kind of
     * preferences among riders) but the planner will take this literally and walk down a transit
     * line to avoid waiting at a stop. This used to be set less than 1 (0.95) which would make
     * waiting offboard preferable to waiting onboard in an interlined trip. That is also
     * undesirable.
     *
     * If we only tried the shortest possible transfer at each stop to neighboring stop patterns,
     * this problem could disappear.
     */
    @QueryParam("waitReluctance")
    protected Double waitReluctance;

    /** How much less bad is waiting at the beginning of the trip (replaces waitReluctance) */
    @QueryParam("waitAtBeginningFactor")
    protected Double waitAtBeginningFactor;

    /** The user's walking speed in meters/second. Defaults to approximately 3 MPH. */
    @QueryParam("walkSpeed")
    protected Double walkSpeed;

    /** The user's biking speed in meters/second. Defaults to approximately 11 MPH, or 9.5 for bikeshare. */
    @QueryParam("bikeSpeed")
    protected Double bikeSpeed;

    /** The time it takes the user to fetch their bike and park it again in seconds.
     *  Defaults to 0. */
    @QueryParam("bikeSwitchTime")
    protected Integer bikeSwitchTime;

    /** The cost of the user fetching their bike and parking it again.
     *  Defaults to 0. */
    @QueryParam("bikeSwitchCost")
    protected Integer bikeSwitchCost;

    /** For bike triangle routing, how much safety matters (range 0-1). */
    @QueryParam("triangleSafetyFactor")
    protected Double triangleSafetyFactor;
    
    /** For bike triangle routing, how much slope matters (range 0-1). */
    @QueryParam("triangleSlopeFactor")
    protected Double triangleSlopeFactor;
    
    /** For bike triangle routing, how much time matters (range 0-1). */            
    @QueryParam("triangleTimeFactor")
    protected Double triangleTimeFactor;

    /** The set of characteristics that the user wants to optimize for. @See OptimizeType */
    @QueryParam("optimize")
    protected OptimizeType optimize;
    
    /** The set of modes that a user is willing to use, with qualifiers stating whether vehicles should be parked, rented, etc. */
    @QueryParam("mode")
    protected QualifiedModeSet modes;

    /** The minimum time, in seconds, between successive trips on different vehicles.
     *  This is designed to allow for imperfect schedule adherence.  This is a minimum;
     *  transfers over longer distances might use a longer time. */
    @QueryParam("minTransferTime")
    protected Integer minTransferTime;

    /** The maximum number of possible itineraries to return. */
    @QueryParam("numItineraries")
    protected Integer numItineraries;

    /**
     * The list of preferred routes. The format is agency_[routename][_routeid], so TriMet_100 (100 is route short name)
     * or Trimet__42 (two underscores, 42 is the route internal ID).
     */
    @QueryParam("preferredRoutes")
    protected String preferredRoutes;

    /** Penalty added for using every route that is not preferred if user set any route as preferred, i.e. number of seconds that we are willing
     * to wait for preferred route. */
    @QueryParam("otherThanPreferredRoutesPenalty")
    protected Integer otherThanPreferredRoutesPenalty;
    
    /** The comma-separated list of preferred agencies. */
    @QueryParam("preferredAgencies")
    protected String preferredAgencies;
    
    /**
     * The list of unpreferred routes. The format is agency_[routename][_routeid], so TriMet_100 (100 is route short name) or Trimet__42 (two
     * underscores, 42 is the route internal ID).
     */
    @QueryParam("unpreferredRoutes")
    protected String unpreferredRoutes;
    
    /** The comma-separated list of unpreferred agencies. */
    @QueryParam("unpreferredAgencies")
    protected String unpreferredAgencies;

    /** Whether intermediate stops -- those that the itinerary passes in a vehicle, but 
     *  does not board or alight at -- should be returned in the response.  For example,
     *  on a Q train trip from Prospect Park to DeKalb Avenue, whether 7th Avenue and
     *  Atlantic Avenue should be included. */
    @QueryParam("showIntermediateStops")
    protected Boolean showIntermediateStops;

    /**
     * Prevents unnecessary transfers by adding a cost for boarding a vehicle. This is the cost that
     * is used when boarding while walking.
     */
    @QueryParam("walkBoardCost")
    protected Integer walkBoardCost;
    
    /**
     * Prevents unnecessary transfers by adding a cost for boarding a vehicle. This is the cost that
     * is used when boarding while cycling. This is usually higher that walkBoardCost.
     */
    @QueryParam("bikeBoardCost")
    protected Integer bikeBoardCost;
    
    /**
     * The comma-separated list of banned routes. The format is agency_[routename][_routeid], so TriMet_100 (100 is route short name) or Trimet__42
     * (two underscores, 42 is the route internal ID).
     */
    @QueryParam("bannedRoutes")
    protected String bannedRoutes;
    
    /** The comma-separated list of banned agencies. */
    @QueryParam("bannedAgencies")
    protected String bannedAgencies;
    
    /** The comma-separated list of banned trips.  The format is agency_trip[:stop*], so:
     * TriMet_24601 or TriMet_24601:0:1:2:17:18:19
     */
    @QueryParam("bannedTrips")
    protected String bannedTrips;

    /** A comma-separated list of banned stops. A stop is banned by ignoring its 
     * pre-board and pre-alight edges. This means the stop will be reachable via the
     * street network. Also, it is still possible to travel through the stop. Just
     * boarding and alighting is prohibited.
     * The format is agencyId_stopId, so: TriMet_2107
     */
    @QueryParam("bannedStops")
    protected String bannedStops;
    
    /** A comma-separated list of banned stops. A stop is banned by ignoring its 
     * pre-board and pre-alight edges. This means the stop will be reachable via the
     * street network. It is not possible to travel through the stop.
     * For example, this parameter can be used when a train station is destroyed, such
     * that no trains can drive through the station anymore.
     * The format is agencyId_stopId, so: TriMet_2107
     */
    @QueryParam("bannedStopsHard")
    protected String bannedStopsHard;
    

    
    
    // ------------------------------------- PHUONG: --------------------------------------------------------
    /**
     * The list of forced stops.  A comma-separated list of forced stops. The format is agencyid:[stopid].
     */
    
    /** The date that the trip should arrive no later than. */
    @QueryParam("dateArrive")
    protected String dateArrive;
    
    /** The time that the trip should arrive no later than. */
    @QueryParam("timeArrive")
    protected String timeArrive;
    
    @QueryParam("timeArriveVisible")
    protected Boolean timeArriveVisible;
    
    @QueryParam("slowSteaming")
    protected Boolean slowSteaming;
    
    @QueryParam("KPIimportance")
    protected Boolean KPIimportance;
    
    @QueryParam("forcedStops")
    protected String forcedStops;
    
    @QueryParam("sortResultType")
    protected Integer sortResultType; //sort Results presented on the web use-interface: 0: weight ascending; 1: C02 ascending; 2:duration ascending,  3: distance ascending; 4:departure ascending; 5: arrival ascending
    
    		
    @QueryParam("choiceOPT")
    protected Integer choiceOPT; //=1 then show all; =2 then show only min duration; =3 then show min CO2;  =4 show min weight;
    
 
    @QueryParam("cost_distance_per_km_train") //0.4Euro/km
    protected Double cost_distance_per_km_train; //cost in euro per km
    
    @QueryParam("cost_distance_per_km_truck") //0.4Euro/km
    protected Double cost_distance_per_km_truck; //cost in euro per km
  
    @QueryParam("cost_distance_per_km_ship") //0.4Euro/km
    protected Double cost_distance_per_km_ship; //cost in euro per km
  
    @QueryParam("cost_per_hour") //35Euro/hour
    protected Double cost_per_hour; //cost in euro per 1hour of driving

    @QueryParam("co2_cost_per_kg") //0.15Euro/kg
    protected Double co2_cost_per_kg; //cost in euro per 1 kg CO2
    
    @QueryParam("co2_per_km_train")
    protected Double co2_per_km_train; //kg CO2 per km for train mode
    
    @QueryParam("co2_per_km_truck")//0.137 kg/km
    protected Double co2_per_km_truck; //kg CO2 per km for truck mode
    
    @QueryParam("co2_per_km_ship")
    protected Double co2_per_km_ship; //kg CO2 per km for ship mode
    
    @QueryParam("co2_per_km_ship_Slow")
    protected Double co2_per_km_ship_Slow; //kg CO2 per km for ship mode (slow velocity)
    @QueryParam("co2_per_km_ship_Medium")
    protected Double co2_per_km_ship_Medium; //kg CO2 per km for ship mode  (medium velocity)
    @QueryParam("co2_per_km_ship_Fast")
    protected Double co2_per_km_ship_Fast; //kg CO2 per km for ship mode  (fast velocity)
    
    @QueryParam("distance_w")
    protected Double distance_w; //weight on the distance in generalized cost
    

    @QueryParam("co2_w")
    protected Double co2_w; //weight on the co2 in generalized cost

    @QueryParam("time_w")
    protected Double time_w; //weight on the travel time in generalized cost
    // ---------------------------------------------------------------------------------------------
    
    /**
     * An additional penalty added to boardings after the first.  The value is in OTP's
     * internal weight units, which are roughly equivalent to seconds.  Set this to a high
     * value to discourage transfers.  Of course, transfers that save significant
     * time or walking will still be taken.
     */
    @QueryParam("transferPenalty")
    protected Integer transferPenalty;
    
    /**
     * An additional penalty added to boardings after the first when the transfer is not
     * preferred. Preferred transfers also include timed transfers. The value is in OTP's
     * internal weight units, which are roughly equivalent to seconds. Set this to a high
     * value to discourage transfers that are not preferred. Of course, transfers that save
     * significant time or walking will still be taken.
     * When no preferred or timed transfer is defined, this value is ignored.
     */
    @QueryParam("nonpreferredTransferPenalty")
    protected Integer nonpreferredTransferPenalty;
    
    /** The maximum number of transfers (that is, one plus the maximum number of boardings)
     *  that a trip will be allowed.  Larger values will slow performance, but could give
     *  better routes.  This is limited on the server side by the MAX_TRANSFERS value in
     *  org.opentripplanner.api.ws.Planner. */
    @QueryParam("maxTransfers")
    protected Integer maxTransfers; //PHUONG: I'm setting maxTransfers = 10 in RoutingRequest.java

    /** If true, goal direction is turned off and a full path tree is built (specify only once) */
    @QueryParam("batch")
    protected Boolean batch;

    /** A transit stop required to be the first stop in the search (AgencyId_StopId) */
    @QueryParam("startTransitStopId")
    protected String startTransitStopId;

    /** A transit trip acting as a starting "state" for depart-onboard routing (AgencyId_TripId) */
    @QueryParam("startTransitTripId")
    protected String startTransitTripId;

    /**
     * When subtracting initial wait time, do not subtract more than this value, to prevent overly
     * optimistic trips. Reasoning is that it is reasonable to delay a trip start 15 minutes to 
     * make a better trip, but that it is not reasonable to delay a trip start 15 hours; if that
     * is to be done, the time needs to be included in the trip time. This number depends on the
     * transit system; for transit systems where trips are planned around the vehicles, this number
     * can be much higher. For instance, it's perfectly reasonable to delay one's trip 12 hours if
     * one is taking a cross-country Amtrak train from Emeryville to Chicago. Has no effect in
     * stock OTP, only in Analyst.
     *
     * A value of 0 means that initial wait time will not be subtracted out (will be clamped to 0).
     * A value of -1 (the default) means that clamping is disabled, so any amount of initial wait 
     * time will be subtracted out.
     */
    @QueryParam("clampInitialWait")
    protected Long clampInitialWait;

    /**
     * If true, this trip will be reverse-optimized on the fly. Otherwise, reverse-optimization
     * will occur once a trip has been chosen (in Analyst, it will not be done at all).
     */
    @QueryParam("reverseOptimizeOnTheFly")
    protected Boolean reverseOptimizeOnTheFly;
        
    @QueryParam("boardSlack")
    private Integer boardSlack;
    
    @QueryParam("alightSlack")
    private Integer alightSlack;

    @QueryParam("locale")
    private String locale;

    /**
     * If true, realtime updates are ignored during this search.
     */
    @QueryParam("ignoreRealtimeUpdates")
    protected Boolean ignoreRealtimeUpdates;

    /**
     * If true, the remaining weight heuristic is disabled. Currently only implemented for the long
     * distance path service.
     */
    @QueryParam("disableRemainingWeightHeuristic")
    protected Boolean disableRemainingWeightHeuristic;
    
    /* 
     * somewhat ugly bug fix: the graphService is only needed here for fetching per-graph time zones. 
     * this should ideally be done when setting the routing context, but at present departure/
     * arrival time is stored in the request as an epoch time with the TZ already resolved, and other
     * code depends on this behavior. (AMB)
     * Alternatively, we could eliminate the separate RoutingRequest objects and just resolve
     * vertices and timezones here right away, but just ignore them in semantic equality checks.
     */
    @Context
    protected OTPServer otpServer;

    /**
     * Range/sanity check the query parameter fields and build a Request object from them.
     *
     * @throws ParameterException when there is a problem interpreting a query parameter
     */
    protected RoutingRequest buildRequest() throws ParameterException {
    	return buildRequest(null);
    }
    
    protected RoutingRequest buildRequest(OTPServer otherOtpServer) throws ParameterException {
    	
    	Router router = null;
    	
    	if(username != null) {
    		routerId = username;
    	}
    	
    	if(otherOtpServer != null){
            router = otherOtpServer.getRouter(routerId);	
    	} else {
            router = otpServer.getRouter(routerId);
    	}
    	
        RoutingRequest request = router.defaultRoutingRequest.clone();
        request.routerId = routerId;
        // The routing request should already contain defaults, which are set when it is initialized or in the JSON
        // router configuration and cloned. We check whether each parameter was supplied before overwriting the default.
    	
        if (fromPlace != null)
            request.setFromString(fromPlace);

        if (toPlace != null)
            request.setToString(toPlace);

        {
            //FIXME: move into setter method on routing request
            TimeZone tz;
            tz = router.graph.getTimeZone();
            if (date == null && time != null) { // Time was provided but not date
                LOG.debug("parsing ISO datetime {}", time);
                try {
                    // If the time query param doesn't specify a timezone, use the graph's default. See issue #1373.
                    DatatypeFactory df = javax.xml.datatype.DatatypeFactory.newInstance();
                    XMLGregorianCalendar xmlGregCal = df.newXMLGregorianCalendar(time);
                    GregorianCalendar gregCal = xmlGregCal.toGregorianCalendar();
                    if (xmlGregCal.getTimezone() == DatatypeConstants.FIELD_UNDEFINED) {
                        gregCal.setTimeZone(tz);
                    }
                    Date d2 = gregCal.getTime();
                    request.setDateTime(d2);
                } catch (DatatypeConfigurationException e) {
                    request.setDateTime(date, time, tz);
                }
            } else {
            	LOG.info(time);
                request.setDateTime(date, time, tz); //PHUONG: set the RoutingRequest.dateTime = the number of seconds since January 1, 1970, 00:00:00 GMT represented in the para (date,time) 
            }
            
            if (timeArriveVisible != null) request.timeArriveVisible = timeArriveVisible;
            if (slowSteaming != null) request.slowSteaming = slowSteaming;
            if (KPIimportance != null) request.KPIimportance = KPIimportance;
            if (distance_w != null) request.distance_w = distance_w;
            if (co2_w != null) request.co2_w = co2_w;
            if (time_w != null) request.time_w = time_w;
            if (co2_cost_per_kg != null) request.co2_cost_per_kg = co2_cost_per_kg;
            if (cost_per_hour != null) request.cost_per_hour = cost_per_hour;
            if (cost_distance_per_km_truck != null) request.cost_distance_per_km_truck = cost_distance_per_km_truck;
            if (cost_distance_per_km_train != null) request.cost_distance_per_km_train = cost_distance_per_km_train;
            if (cost_distance_per_km_ship != null) request.cost_distance_per_km_ship = cost_distance_per_km_ship;
            if (KRI_time_w != null) request.KRI_time_w = KRI_time_w;
            if (KRI_flexibility_w != null) request.KRI_flexibility_w = KRI_flexibility_w;
            if (KRI_safety_w != null) request.KRI_safety_w = KRI_safety_w;
            if (KRI_cost_w != null) request.KRI_cost_w = KRI_cost_w;
            
            //Giovanni add capacityRequest
            if (capacityRequest != null) request.capacityRequest = capacityRequest;
            
            
            if (timeArriveVisible != null && timeArriveVisible)
	        {
            	if (dateArrive == null && timeArrive != null) { // Time was provided but not date
            		LOG.debug("parsing ISO datetime {}", timeArrive);
	                try {
	                    // If the time query param doesn't specify a timezone, use the graph's default. See issue #1373.
	                    DatatypeFactory df = javax.xml.datatype.DatatypeFactory.newInstance();
	                    XMLGregorianCalendar xmlGregCal = df.newXMLGregorianCalendar(timeArrive);
	                    GregorianCalendar gregCal = xmlGregCal.toGregorianCalendar();
	                    if (xmlGregCal.getTimezone() == DatatypeConstants.FIELD_UNDEFINED) {
	                        gregCal.setTimeZone(tz);
	                    }
	                    Date d2 = gregCal.getTime();
	                    request.setDateTimeArrive(d2);
	                } catch (DatatypeConfigurationException e) {
	                    request.setDateTimeArrive(dateArrive, timeArrive, tz);
	                }
	            } else {
	                request.setDateTimeArrive(dateArrive, timeArrive, tz);
	            }
            }
	        
	                
        }

        if(driverRestTime != null) request.driverRestTime = driverRestTime;

        if (wheelchair != null)
            request.setWheelchairAccessible(wheelchair);
        
        if (numItineraries != null)
            request.setNumItineraries(numItineraries);
        
        if (maxWalkDistance != null)
            request.setMaxWalkDistance(maxWalkDistance);

        if (maxPreTransitTime != null)
            request.setMaxPreTransitTime(maxPreTransitTime);

        if (walkReluctance != null)
            request.setWalkReluctance(walkReluctance);

        if (waitReluctance != null)
            request.setWaitReluctance(waitReluctance);

        if (waitAtBeginningFactor != null)
            request.setWaitAtBeginningFactor(waitAtBeginningFactor);

        if (walkSpeed != null)
            request.walkSpeed = walkSpeed;

        if (bikeSpeed != null)
            request.bikeSpeed = bikeSpeed;

        if (bikeSwitchTime != null)
            request.bikeSwitchTime = bikeSwitchTime;

        if (bikeSwitchCost != null)
            request.bikeSwitchCost = bikeSwitchCost;

        if (optimize != null) {
            // Optimize types are basically combined presets of routing parameters, except for triangle
            request.setOptimize(optimize);
            if (optimize == OptimizeType.TRIANGLE) {
                if (triangleSafetyFactor == null || triangleSlopeFactor == null || triangleTimeFactor == null) {
                    throw new ParameterException(Message.UNDERSPECIFIED_TRIANGLE);
                }
                if (triangleSafetyFactor == null && triangleSlopeFactor == null && triangleTimeFactor == null) {
                    throw new ParameterException(Message.TRIANGLE_VALUES_NOT_SET);
                }
                // FIXME couldn't this be simplified by only specifying TWO of the values?
                if (Math.abs(triangleSafetyFactor+ triangleSlopeFactor + triangleTimeFactor - 1) > Math.ulp(1) * 3) {
                    throw new ParameterException(Message.TRIANGLE_NOT_AFFINE);
                }
                request.setTriangleSafetyFactor(triangleSafetyFactor);
                request.setTriangleSlopeFactor(triangleSlopeFactor);
                request.setTriangleTimeFactor(triangleTimeFactor);
            }
        }

        if (arriveBy != null)
            request.setArriveBy(arriveBy);

        if (showIntermediateStops != null)
            request.showIntermediateStops = showIntermediateStops;

        if (sortResultType != null)
            request.sortResultType = sortResultType;

        //EDIT - Riccardo (19/04/2017): force the search to pass by one or more routes
        if ( ForcedRoutes != null && !ForcedRoutes.equals("") ) {
        	request.setPreferredRoutes(ForcedRoutes);
        	if(passBy == null) passBy = "";
        	for( String s : ForcedRoutes.split(",") ){

        		String[] agencyStop = s.split("__");
        		String agency = agencyStop[0];
        		String[] departureArray = agencyStop[1].split("\\+")[1].split("_");
        		String[] arrivalArray = agencyStop[1].split("\\+")[2].split("_");

        		String locationD = departureArray[1] + "," + departureArray[2];
        		String nameD = departureArray[0];
        		String cityD = nameD + ":" + locationD;
        		String cityComparisonD = nameD + "::" + locationD;
        		
        		String locationA = arrivalArray[1] + "," + arrivalArray[2];
        		String nameA = arrivalArray[0];
        		String cityA = nameA + ":" + locationA;
        		String cityComparisonA = nameA + "::" + locationA;
//        		String label = agency + ":" + city;

        		String cityRightFormatD = "";
        		String cityRightFormatA = "";

        		for(String w : cityD.split(" ")){
        			if(w.length() > 1) cityRightFormatD += w.substring(0, 1) + w.substring(1).toLowerCase() + " ";
        			else cityRightFormatD += w + " ";
        		}
        		cityRightFormatD = cityRightFormatD.substring(0, cityRightFormatD.length() - 1);

        		for(String w : cityA.split(" ")){
        			if(w.length() > 1) cityRightFormatA += w.substring(0, 1) + w.substring(1).toLowerCase() + " ";
        			else cityRightFormatA += w + " ";
        		}
        		cityRightFormatA = cityRightFormatA.substring(0, cityRightFormatA.length() - 1);
        		
        		if(!fromPlace.toUpperCase().equals(cityComparisonD)) {
            		if(!passBy.equals("")) passBy += ";";
            		if(!passBy.contains(cityRightFormatD) ) passBy += cityRightFormatD;
        		}
        		
        		if(!toPlace.toUpperCase().equals(cityComparisonA)) {
            		if(!passBy.equals("")) passBy += ";";
            		if(!passBy.contains(cityRightFormatA) ) passBy += cityRightFormatA;
        		}
        		


//        		if ( !fromPlace.contains(cityRightFormat) && !toPlace.contains(cityRightFormat)){
////            		Vertex v = router.graph.getVertex(label);
//
//        		}

        	}
        	System.out.println(passBy);

        }
        //EDIT - Riccardo (19/04/2017): END
        
        //EDIT - Riccardo (19/04/2017): force the search to pass by one or more cities
    	if(passBy != null && passBy != ""){
    		request.setPassByStops(passBy);
    	}
        //EDIT - Riccardo (19/04/2017): END

        //EDIT - Riccardo (03/05/2017): forced stops implemented
        if (request.passByCities != null){
//            double[] distanceFromOrigin = new double [request.passByCities.size()];
            
            request.intermediatePlaces = new ArrayList<>();
            
            for(int i = 0; i < request.passByCities.size(); i++){

            	GenericLocation gl = request.passByCities.get(i);
                	request.intermediatePlaces.add(gl);
//                	distanceFromOrigin[i] = SphericalDistanceLibrary.distanceP(request.from.lat, request.from.lng, request.intermediatePlaces.get(i).lat, request.intermediatePlaces.get(i).lng);
            }
                        
            //The following code is needed if we want to order the intermediate from the nearest to the farther
//            double tempDistanceFromOrigin;
//            GenericLocation tempIntermediatePlace;
//            for(int i = distanceFromOrigin.length - 1; i >= 0; i--){
//            	for(int jj = 0; jj < i; jj ++){
//                  	if(distanceFromOrigin[jj] > distanceFromOrigin[jj + 1]){
//                  		tempDistanceFromOrigin = distanceFromOrigin[jj];
//                  		distanceFromOrigin[jj] = distanceFromOrigin[jj + 1];
//                  		distanceFromOrigin[jj + 1] = tempDistanceFromOrigin;
//                  		
//                  		tempIntermediatePlace = request.intermediatePlaces.get(jj);
//                  		request.intermediatePlaces.set(jj, request.intermediatePlaces.get(jj + 1));
//                  		request.intermediatePlaces.set(jj + 1, tempIntermediatePlace);
//                  	}	
//            	}
//            }
        }
        //EDIT - Riccardo (03/05/2017): END
        
        if (preferredRoutes != null)
            request.setPreferredRoutes(preferredRoutes);

        if (otherThanPreferredRoutesPenalty != null)
            request.setOtherThanPreferredRoutesPenalty(otherThanPreferredRoutesPenalty);

        if (preferredAgencies != null)
            request.setPreferredAgencies(preferredAgencies);

        if (unpreferredRoutes != null)
            request.setUnpreferredRoutes(unpreferredRoutes);

        if (unpreferredAgencies != null)
            request.setUnpreferredAgencies(unpreferredAgencies);

        if (walkBoardCost != null)
            request.setWalkBoardCost(walkBoardCost);

        if (bikeBoardCost != null)
            request.setBikeBoardCost(bikeBoardCost);

        if (bannedRoutes != null)
            request.setBannedRoutes(bannedRoutes);

        if (bannedAgencies != null)
            request.setBannedAgencies(bannedAgencies);

        HashMap<AgencyAndId, BannedStopSet> bannedTripMap = makeBannedTripMap(bannedTrips);
        if (bannedTripMap != null)
            request.bannedTrips = bannedTripMap;

        //Riccardo (13-06-2017): banned the stops for all the agencies
        if (BannedStops != null){
        	String stops = "";
        	for(String city : BannedStops.split(";")){
//        		System.out.println(city);
        		city = city.toUpperCase();
                for(String feed : router.graph.getFeedIds()){                
                    stops += feed + "_" + city.split(":")[0] + ";";
//                    System.out.println(feed + ":" + city);
                }
        	}
            request.setBannedStops(stops);
        }
        //Riccardo (13-06-2017): END

        if (bannedStopsHard != null)
            request.setBannedStopsHard(bannedStopsHard);

        if (forcedStops != null)
            request.setForcedStops(forcedStops);

        // The "Least transfers" optimization is accomplished via an increased transfer penalty.
        // See comment on RoutingRequest.transferPentalty.
        if (transferPenalty != null) request.transferPenalty = transferPenalty;
        if (optimize == OptimizeType.TRANSFERS) {
            optimize = OptimizeType.QUICK;
            request.transferPenalty += 1800;
        }

        if (batch != null)
            request.batch = batch;

        if (optimize != null)
            request.setOptimize(optimize);

        /* Temporary code to get bike/car parking and renting working. */
        if (modes != null) {
            modes.applyToRoutingRequest(request);
            request.setModes(request.modes);
        } else {
        	TraverseModeSet modesSet = new TraverseModeSet();
        	modesSet.setBus(true);
        	modesSet.setRail(true);
        	modesSet.setFerry(true);
        	request.setModes(modesSet);
        }

        if (request.allowBikeRental && bikeSpeed == null) {
            //slower bike speed for bike sharing, based on empirical evidence from DC.
            request.bikeSpeed = 4.3;
        }

//        if (boardSlack != null)
//            request.boardSlack = boardSlack;
            request.boardSlack = 600;//Riccardo (11-05-2017): set default boarding time (REMOVE IT LATER)


//        if (alightSlack != null)
//            request.alightSlack = alightSlack;
            request.boardSlack = 600;//Riccardo (11-05-2017): set default alight time (REMOVE IT LATER)


//        if (minTransferTime != null)
//            request.transferSlack = minTransferTime; // TODO rename field in routingrequest
          request.transferSlack = 600;//Riccardo (11-05-2017): set default boarding time (REMOVE IT LATER)

        if (nonpreferredTransferPenalty != null)
            request.nonpreferredTransferPenalty = nonpreferredTransferPenalty;

        if (request.boardSlack + request.alightSlack > request.transferSlack) {
            throw new RuntimeException("Invalid parameters: " +
                    "transfer slack must be greater than or equal to board slack plus alight slack");
        }

        if (maxTransfers != null)
            request.maxTransfers = maxTransfers;

        final long NOW_THRESHOLD_MILLIS = 15 * 60 * 60 * 1000;
        boolean tripPlannedForNow = Math.abs(request.getDateTime().getTime() - new Date().getTime()) < NOW_THRESHOLD_MILLIS;
        request.useBikeRentalAvailabilityInformation = (tripPlannedForNow); // TODO the same thing for GTFS-RT

        if (startTransitStopId != null && !startTransitStopId.isEmpty())
            request.startingTransitStopId = AgencyAndId.convertFromString(startTransitStopId);

        if (startTransitTripId != null && !startTransitTripId.isEmpty())
            request.startingTransitTripId = AgencyAndId.convertFromString(startTransitTripId);

        if (clampInitialWait != null)
            request.clampInitialWait = clampInitialWait;

        if (reverseOptimizeOnTheFly != null)
            request.reverseOptimizeOnTheFly = reverseOptimizeOnTheFly;

        if (ignoreRealtimeUpdates != null)
            request.ignoreRealtimeUpdates = ignoreRealtimeUpdates;

        if (disableRemainingWeightHeuristic != null)
            request.disableRemainingWeightHeuristic = disableRemainingWeightHeuristic;

        //getLocale function returns defaultLocale if locale is null
        request.locale = ResourceBundleSingleton.INSTANCE.getLocale(locale);
        
//    	System.out.println("Forced Routes:");
//        System.out.println(ForcedRoutes);
//        System.out.println(request.preferredRoutes);
//    	System.out.println("Forced Stops:");
//        System.out.println(passBy);
//        for(GenericLocation gl : request.intermediatePlaces){
//        	System.out.println(gl);
//        }
//    	System.out.println("Banned Routes:");
//        System.out.println(bannedRoutes);
//        System.out.println(request.bannedRoutes);
//    	System.out.println("Banned Stops:");
//        System.out.println(BannedStops);
//        System.out.println(request.bannedStops);
        
        return request;
    }

    //Riccardo (19-06-2017): copy the search options
 protected void copyRequest(RoutingResource rs)  {
        fromPlace = rs.fromPlace;
        toPlace = rs.toPlace;
        to2ndPlace = rs.to2ndPlace;
        date = rs.date;
        dateArrive = rs.dateArrive;
        otherDate = rs.otherDate;
        timeArriveVisible = rs.timeArriveVisible;
        otherTimeArriveVisible = rs.otherTimeArriveVisible;
        modes = rs.modes;
        cost_distance_per_km_ship = rs.cost_distance_per_km_ship;
        cost_distance_per_km_truck = rs.cost_distance_per_km_truck;
        cost_distance_per_km_train = rs.cost_distance_per_km_train;
        co2_cost_per_kg = rs.co2_cost_per_kg;
        cost_per_hour = rs.cost_per_hour;
        distance_w = rs.distance_w;
        co2_w = rs.co2_w;
        time_w = rs.time_w;
        ForcedRoutes = rs.ForcedRoutes;
        passBy = rs.passBy;
        BannedStops = rs.BannedStops;
        bannedRoutes = rs.bannedRoutes;
    }
 //Riccardo (19-06-2017): END

    /**
     * Take a string in the format agency:id or agency:id:1:2:3:4.
     * TODO Improve Javadoc. What does this even mean? Why are there so many colons and numbers?
     * Convert to a Map from trip --> set of int.
     */
    private HashMap<AgencyAndId, BannedStopSet> makeBannedTripMap(String banned) {
        if (banned == null) {
            return null;
        }
        
        HashMap<AgencyAndId, BannedStopSet> bannedTripMap = new HashMap<AgencyAndId, BannedStopSet>();
        String[] tripStrings = banned.split(",");
        for (String tripString : tripStrings) {
            // TODO this apparently allows banning stops within a trip with integers. Why?
            String[] parts = tripString.split(":");
            if (parts.length < 2) continue; // throw exception?
            String agencyIdString = parts[0];
            String tripIdString = parts[1];
            AgencyAndId tripId = new AgencyAndId(agencyIdString, tripIdString);
            BannedStopSet bannedStops;
            if (parts.length == 2) {
                bannedStops = BannedStopSet.ALL;
            } else {
                bannedStops = new BannedStopSet();
                for (int i = 2; i < parts.length; ++i) {
                    bannedStops.add(Integer.parseInt(parts[i]));
                }
            }
            bannedTripMap.put(tripId, bannedStops);
        }
        return bannedTripMap;
    }

}
