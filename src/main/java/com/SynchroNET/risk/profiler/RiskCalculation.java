package com.SynchroNET.risk.profiler;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeMap;

import org.opentripplanner.api.model.Itinerary;
import org.opentripplanner.api.model.Leg;
import org.opentripplanner.api.model.Place;
import org.opentripplanner.api.model.TripPlan;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.SynchroNET.utilities.SpecialRouteFinder;

public class RiskCalculation {

	/*EDIT - Yuanyuan(08/05/2017) - it contains the actions to store data into database
	 * and add time disturbance to see the feasibility of each route
	 * */
	private static final Logger LOG = LoggerFactory.getLogger(RiskCalculation.class);
	private TripPlan plan;
	private HashMap<Integer, Leg> legMap; // to store link id and corresponding leg
	private HashMap<Integer, Leg> planMap; // to store plan id and corresponding leg
	private HashMap<Itinerary, List<Integer>> routeMap; // to store route and corresponding links
	private HashMap<Integer, Integer> timeDevMap; // to store link id and corresponding time deviation
	
	public RiskCalculation(TripPlan plan) {
		this.plan = plan;
		this.planMap = new HashMap<Integer, Leg>();
		this.routeMap = new HashMap<Itinerary, List<Integer>>();
		this.timeDevMap = new HashMap<Integer, Integer>();
	}
	
	public void convertToDatabase() throws Exception {
		String from = plan.from.name;
		String to = plan.to.name;
		List<Itinerary> itineraryList = plan.itinerary;
		LOG.info("The size of the itinerary is "+itineraryList.size());
		for (Itinerary itinerary : itineraryList) {
			// test the id of itinerary
			// System.out.println("ID is "+itinerary.getID());
			legMap = new HashMap<Integer, Leg>(); // legMap is only for current itinerary
			Calendar startTime = itinerary.startTime;
			Calendar endTime = itinerary.endTime;
			List<Leg> legs = itinerary.legs;
			List<Integer> legIds = new LinkedList<Integer>();
			LOG.info("Itenerary ");
			for (Leg leg : legs) {
				// LOG.info("from " + leg.from.name + " to " + leg.to.name);
				int legId = addLegs(leg);
				legIds.add(legId);
				legMap.put(legId, leg);
			}
			
			int RID = RiskDataBaseManager.addRoutes(from, to, legIds);
			int SID = RiskDataBaseManager.addRouteSchedule(RID, startTime, endTime);
			// Add planned links
			List<Integer> plannedLegIds = new LinkedList<Integer>();
			for (Integer i : legMap.keySet()) {
				LOG.info("Test " + i);
				Leg leg = legMap.get(i);
				int plannedId = RiskDataBaseManager.addPlannedLegs(i, SID, leg.startTime, leg.endTime);
				planMap.put(plannedId, leg);
				// System.out.println("successful plannedId is " + plannedId);
				plannedLegIds.add(plannedId);
				/*EDIT(8/14/2017)-Yuanyuan: assume executed are same with planned, just for testing safety*/
				// RiskDataBaseManager.addExecutedLegs(i, plannedId, leg.startTime, leg.endTime);
				/*EDIT(8/24/2017)-Yuanyuan: assume executed are planned+time deviation generated by distribution function, just for testing text mining on time deviation*/
				DisturbanceGeneration disturbance = new DisturbanceGeneration(leg, 0);
				int timeDev = disturbance.getTimeDev(leg);
				// Calendar executedEnd = leg.endTime;
				Calendar executedEnd = Calendar.getInstance();
				executedEnd.setTime(leg.endTime.getTime());
				// LOG.info("The current end date is: "+executedEnd.getTime()+" will add "+timeDev);
				executedEnd.add(Calendar.MINUTE, timeDev);
				// LOG.info("The current end date becomes into: "+executedEnd.getTime());
				RiskDataBaseManager.addExecutedLegs(i, plannedId, leg.startTime, executedEnd);
				// legIds.add(legId); // later should retrieve it for saving into Executed_links table
			}
			routeMap.put(itinerary, plannedLegIds);
		}
		
	}


	private int addLegs(Leg leg) {
		String mode = leg.mode;
		String from = leg.from.name;
		String to = leg.to.name;
		String agency = leg.agencyName;
		// EDIT-Yuanyuan(16/05/2017) - to distinguish fast, slow and medium ships
		/* if (leg.route.toLowerCase().equals("fast"))
			mode = "fastShip";
		else {
			if (leg.route.toLowerCase().equals("medium"))
				mode = "mediumShip";
			else
				if (leg.route.toLowerCase().equals("slow"))
					mode = "slowShip";
		} */
		
		// 1st add to links table, which is for storing all legs
		int LID = RiskDataBaseManager.addLinks(from, to, mode, agency);
		
		return LID;
	}
	
	// add time disturbance to each link
	public void addTimeDev() throws Exception {
		
		for (Integer i : planMap.keySet()) {
			Leg leg = planMap.get(i);
			DisturbanceGeneration disturbance = new DisturbanceGeneration(leg, 0);
			int timeDev = disturbance.getTimeDev(leg);
			timeDevMap.put(i, timeDev);
			// add into database, in the simulation, assume all delays are caused on the way?
			RiskDataBaseManager.addTimeDev(i, timeDev, "W");
		}
	}
	// TODO: Add executed_links method

	/* private int getTimeDev(Leg leg) {
		
		int timeDev = 0;
		long duration = leg.endTime.getTimeInMillis()/(60*1000) - leg.startTime.getTimeInMillis()/(60*1000);
		if (leg.isTRUCKLeg()) {
			timeDev = RandomNumber.timeDevTruck((int)duration); // It is BUS
		} else {
			if (leg.isSHIPLeg()) {
				if (leg.route.toLowerCase().equals("fast"))
					timeDev = RandomNumber.timeDevFastShip((int)duration);
				else {
					if (leg.route.toLowerCase().equals("slow"))
						timeDev = RandomNumber.timeDevSlowShip((int)duration);
				}
			} else {
				if (leg.isTRAINLeg()) {
					timeDev = RandomNumber.timeDevTrain((int)duration);
				} else {
					System.out.println("Unknown freight!");
					// throw excpetion?
				}
			}
		}
		return timeDev;
	} */
	
	// Calculate the feasibility of the route
	public void calFeasibility() {
		for (Itinerary itinerary : routeMap.keySet()) {
			boolean flag = false;
			List<Integer> plannedIds = routeMap.get(itinerary);
			// sort the plannedIds according to the start time
			sortPlans(plannedIds);
			Iterator<Integer> itr = plannedIds.iterator();
			int previousId = 0;
			while(itr.hasNext()) {
				int nextId = (int) itr.next();
				if (previousId !=0 ) {
					long diffMilliseconds = planMap.get(nextId).startTime.getTime().getTime() - planMap.get(previousId).endTime.getTime().getTime();
					int diffMin = (int) (diffMilliseconds / (1000*60));
					int timeDev = timeDevMap.get(previousId);
					if (diffMin < timeDev) {
						LOG.info("You will miss the trip...");
						flag = true;
						break; 
					}
				}
				previousId = nextId; 
				
			}
			if (!flag)
				LOG.info("You will not miss the trip!");
		}
	}

	private void sortPlans(List<Integer> plannedIds) {
		Collections.sort(plannedIds, new Comparator<Integer>() {
			public int compare(Integer i1, Integer i2) {
				return planMap.get(i1).startTime.compareTo(planMap.get(i2).startTime);
			}
		});
		/* for (int id : plannedIds)
			System.out.println("Check " + id + " " + planMap.get(id).startTime.getTime()); */
		
	}

	/*This is for testing the function:findLaterItinerary*/
	public void calFeasibility(SpecialRouteFinder srf) {
		for (Itinerary itinerary : routeMap.keySet()) {
			boolean flag = false;
			List<Integer> plannedIds = routeMap.get(itinerary);
			// sort the plannedIds according to the start time
			sortPlans(plannedIds);
			Iterator<Integer> itr = plannedIds.iterator();
			int previousId = 0;
			while(itr.hasNext()) {
				int nextId = (int) itr.next();
				if (previousId !=0 ) {
					long diffMilliseconds = planMap.get(nextId).startTime.getTime().getTime() - planMap.get(previousId).endTime.getTime().getTime();
					int diffMin = (int) (diffMilliseconds / (1000*60));
					int timeDev = timeDevMap.get(previousId);
					if (diffMin < timeDev) {
						// System.out.println("You will miss the trip...");
						// System.out.println("Asking for a new route:");
						// get a new itinerary according to the infeasible points.
						flag = true;
						break; // TO MODIFY(And put into table)
					}
					// Just for testing
					Leg arrival = planMap.get(nextId);
					String departureS = arrival.from.name+"::"+arrival.from.lat+","+arrival.from.lon;
					String arrivalS = arrival.to.name+"::"+arrival.to.lat+","+arrival.to.lon;
					// convert long into Date
					long time = planMap.get(nextId).startTime.getTime().getTime() + timeDev;
					Calendar c = Calendar.getInstance();
					c.setTimeInMillis(time);
					Date departureDate = (Date)c.getTime();
					// Itinerary newItinerary = srf.findLaterItineraryByLegs(departure, arrival);
					Itinerary newItinerary = srf.findLaterItinerary(departureS, arrivalS, departureDate);
					// System.out.println("Previous link is "+arrival.from.name + "->" + arrival.to.name);
					// System.out.println("Old route:"+itinerary.toString());
					// System.out.println("Get new route:"+newItinerary.toString());
				}
				previousId = nextId; 
				
			}
			// if (!flag)
			//	System.out.println("You will not miss the trip!");
		}
	}
}
